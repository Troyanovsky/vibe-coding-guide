# Lesson 2: Vibe Coding Tools

## What Vibe Coding Tools Are Out There

So now you know what vibe coding is. But where do you actually... vibe code? The good news is that AI coding tools have exploded in the past couple of years, but for some, the number of vibe coding tools might be just overwhelming. (I've seen countless posts on Reddit asking about which tool to use, maybe every day.)

Let's take a quick look of what options you have. 

## AI Chatbots for Simple Pages

AI chatbots are probably the most easily accessible for many of you, especially if you've never had any coding experience before. You probably already use one of the AI chatbots like **[ChatGPT](https://chat.openai.com/)**, **[Claude](https://claude.ai/)**, **[Gemini](https://gemini.google.com/app)/[AI Studio](https://aistudio.google.com/)**, **[Poe](https://poe.com/)**, etc. in your daily life, so they're a great place to get started.

Many of these platforms now have something called "Canvas" or "Artifacts" -- think of these as live preview windows where you can see rendered code generated by these mdoels as you chat. And you can tweak them by continuing chatting with them. Claude's Artifacts are particularly good at this, and Poe's Previews let you interact with web applications right in the chat. You can also easily share the generated app/website to others with a sharable link. You can get from ideas to a working prototype in just a few sentences and you don't need to worry about environment or dependencies.

Chatbots with live preview are perfect for the messy, exploratory phase of any project. You can describe what you want to build in plain English (or whatever langauge you speak), ask "what if" questions, get suggestions for different approaches, and even have the AI help you break down complex ideas into manageable pieces.

The downside? Chat interfaces can feel limiting when you're working on anything beyond simple prototypes. Or if you need to work with some features that require native capabilities.

## Visual, Hosted Platforms for Quick Prototypes

If you're a designer or PM who thinks visually, platforms like **V0.dev**, **bolt.new** or **Figma Make** might be your handy choice. These tools specialize in turning descriptions (or even sketches) into good-looking pages, thanks to their own prompting and pre-defined components. Think of them as a step-up from the chat interfce with some specializations.

[V0](https://v0.dev/) and [bolt.new](https://bolt.new/) simplifies the workflow by optimizing visual and deployment. You describe what you want, get the code, tweak it, and deploy. It can even take inspiration from design mockups you upload or imported from Figma. They can even help you build some apps with a backend that can be connected to databases, payments, etc so that you can turn your app into a monetizable product.

[Figma Make](https://www.figma.com/make/) is another tools from Figma that aims at helping designers quickly visualize their design. Designers can share their design with the tool, have it code, live preview on the side, make changes and then hand off code to developers for further development.

Depending on your goal, you may use them to get your initial "mood board" vibe with a few variations; you may also use them for for "V0" version before moving to other tools to refine into MVP prodcut; or if you're already satisfied with what they give you, just deploy it and call it a day.

## Editors and Plugins for Core Vibing

For both beginners and experiences developers, the most common way to use AI is through editors. **AI code editors & plugins** give you AI power right where most of coding already happens so you have a seamless transition experience.

**[Cursor](https://www.cursor.com/)** is probably the star of this category. It's VSCode fork with many of their AI capabilities built in. If you're already using VSCode, the transition is seamless -- Cursor can import all your existing configurations and extensions with a few clicks. In addition to models from many providers in the market, they also trained their own models that solved some of the common issues with AI coding, like applying diffs and predictive edits (Many people prefer Cursor because of the Cursor Tab feature, where you just press Tab to accept the suggested edit).

**[Windsurf](https://windsurf.com/)** offers both a standalone editor and plugins for different IDEs. The standalone version has some interesting features like "Cascade" for building entire applications from scratch by breaking down your idea, architecting it, planning the development, and then coding it. They also have a "Supercomplete" that tries to predict what you want to do next (similar to Cursor tab).

Another great choice is **[Augment Code](https://www.augmentcode.com/)**. It's a plugin for editors like VSCode and Jetbrains. It does magic for large codebases, thanks to their strategy and optimizations for codebase indexing. (They've got [a blog](https://www.augmentcode.com/blog/a-real-time-index-for-your-codebase-secure-personal-scalable) covering it.) It has a smart context engine that understands entire codebases and offers different modes for different types of work. You can start with a 14-day free trial with 300 messages. 

**[GitHub Copilot](https://github.com/features/copilot)** is another choice if you're a student or want a low-cost tool. Although not as powerful as the other tools, it's a good starting point and has a free plan for students.

## CLI Tools for the Experienced

**CLI tools** like **[Claude Code](https://www.anthropic.com/claude-code)** and **[Aider](http://aider.chat/)** are for when you want to stay in your terminal and let AI work directly with your codebase. These tools understand entire projects, not just individual files, which makes them incredibly powerful for real development work.

Claude Code is like having an AI pair programmer who never gets tired. It can edit files across your entire codebase, fix bugs, answer questions about your architecture, and even handle git operations. You can even have mulitple Claude Code agents working on different parts of your code simutaneously.

Aider takes a similar approach but supports multiple AI models from other providers. They even have [a leaderboard](https://aider.chat/docs/leaderboards/) to compare different models for coding.

The beauty of CLI tools is that they work with your existing workflow. You don't need to learn a new interface -- just chat with AI right in your terminal.

## My Recommendations

Here's how I'd think about choosing your tools:

**Start with chat interfaces** for ideation and exploring your ideas. They're the most approachable and help you think through what you actually want to build. Use them to prototype quickly and get a feel for what's possible.

**Try UI generators** when you need to see visual progress fast. They're perfect for that "let me see how this might look" phase and for creating variations to explore different directions.

**Move to CLI tools or editors** when you're ready to implement and iterate seriously. These tools understand context better and can handle the complexity of real projects.

For most people, I'd recommend starting with **Cursor** as your main development environment (they have free trials and you can use free models like Gemini 2.5 Flash for simpler projects). It hits the sweet spot of being approachable for beginners while still being powerful enough for experienced developers. Plus, the learning curve is gentle if you're already familiar with VSCode.

## Setting Up Your New Coding Environment

Let's use Cursor as an exmaple of setting up your AI coding tool. Although interface may be different for different tools, many priciples work for all.

When you first open Cursor, you'll notice it looks almost identical to VSCode. The interface has three main areas where you'll interact with AI: a directory explorer on the left, an editor in the middle, and a chat panel on the right.

### Choosing Your AI Models

You get to pick from multiple AI models in Cursor, and each one has different strengths. Think of it like having different specialists on your team.

You'll want to set up 3-4 models for different purposes:

**A thinking model** for planning and architecture -- these are the heavy hitters like o3 or Claude 4 Opus with thinking enabled. Use these when you're figuring out how to breakdown a complex problem into manageable tasks or when you need to think through the overall structure of what you're building.

**A long-context model** for understanding large codebases -- Gemini 2.5 Pro or Flash are great here. When you're working with many files and need the AI to understand how everything fits together, these models can handle much more information at once thanks to their million-token context size. (You even get to use 2.5 Flash free if you get an API key from AI Studio, OpenRouter, or on Cursor.)

**Workhorse coding models** like Claude 3.7/4 Sonnet for the day-to-day coding work. These are fast, reliable, and great at following specific instructions once you have a plan.

Keep in mind that AI models evolve incredibly quickly -- by the time you're reading this, there might be newer, better options available. The key principle remains the same: **use powerful thinking models for planning and fast, reliable models for executing those plans**.

### MCP: Giving Your AI Superpowers

MCP (Model Context Protocol) is a way to give your AI access to additional tools and information. Think of it like installing apps on your phone -- each MCP tool adds new capabilities.

One MCP server I'd recommend starting with is **[context7](https://context7.com/)**, which helps the AI get up-to-date documentation of libraries. This can greatly reduce the chance of your LLM model hallucinating or using a deprecated method in a library.

We'll dive deeper into MCP in later lessons, but for now, just know that it's a way to extend what your AI can do beyond just reading and writing code.

### Rules for AI: Teaching Your Assistant

Another very important setup that some may overlook is: **Rules for AI**. In Cursor, this is a file called `.cursorrules`. (In Claude Code, it's called `Claude.md` and similar for other tools.) Think of it as a instruction manual for how you want the AI to behave. Some tools may have more fine-grained project-level rules that you can set up.

You can specify coding styles, preferred libraries, best practices, workflows. For example, you might include rules about using TypeScript, following certain naming conventions, or always including comments for complex logic.

For a very simple set up, here is my simple version:
```
## Workflow
1. Understand user request and examine existing codebase thoroughly.  
2. Propose step-by-step solution plan.  
3. Implement changes per plan.  
4. Verify changes via tests and preserve existing functionality.  
5. Summarize changes concisely.  

## Code Quality Principles
- Adhere to DRY, KISS, YAGNI, and SOLID principles.  
- Don't write duplicate code, use helper function instead.
- Ensure correctness, efficiency, and maintainability.  

## Structure and Formatting
- Maintain reasonable limits for: Line length and Function/component size and complexity  
- Use logical modules/helpers.  
- Explicitly mark code changes (keep/remove/edit).  

## Naming and Security
- Use descriptive, consistent names.  
- Avoid hardcoded literals/credentials.  

## Documentation
- Include meaningful, non-redundant block comments for functions and in-line comments.  

## Other
- Split multiple changes into separate code blocks.
```

This rule gives instructions on how it should approach problems by first understanding them, how to write simple & understandable code, and documentation. I found it very useful and helps the AI think carefully before execution, leading to better solutions, higher quality code and less back-and-forth.

For more advanced rules, the community has created tons of great examples -- check out the **[awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules)** or **[agent rules](https://github.com/steipete/agent-rules)** repository on GitHub for inspiration. You'll find rules for different frameworks, languages, and project types that you can adapt for your own work.

## Your Next Steps

Don't feel like you need to master all these tools at once. Start with one that matches your current comfort level -- maybe a chat interface if you're new to coding, or Cursor if you're already comfortable with development environments.

The beauty of vibe coding is that you can start building things immediately, even if you don't understand every detail of how the tools work. As you get more comfortable, you can explore additional tools and features that help you work faster and build more complex projects.

In our next lesson, we'll dive into actually using these tools to build your first project and start developing that all-important "vibe" for working with AI effectively.