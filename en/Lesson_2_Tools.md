# Lesson 2: Vibe Coding Tools

## What Vibe Coding Tools Are Out There

So now you know what vibe coding is. But where do you actually... vibe code? The good news is that AI coding tools have exploded in the past couple of years, but for some, the number of vibe coding tools might be just overwhelming. (I've seen countless posts on Reddit asking about which tool to use, maybe every day.)

Let's take a quick look of what options you have. 

## AI Chatbots for Simple Pages

AI chatbots are probably the most easily accessible for many of you, especially if you've never had any coding experience before. You probably already use one of the AI chatbots like **ChatGPT**, **Claude**, **Gemini/AI Studio**, **Poe**, etc. in your daily life, so they're a great place to get started.

Many of these platforms now have something called "Canvas" or "Artifacts" -- think of these as live preview windows where you can see rendered code generated by these mdoels as you chat. And you can tweak them by continuing chatting with them. Claude's Artifacts are particularly good at this, and Poe's Previews let you interact with web applications right in the chat. You can also easily share the generated app/website to others with a sharable link. You can get from ideas to a working prototype in just a few sentences and you don't need to worry about environment or dependencies.

Chatbots with live preview are perfect for the messy, exploratory phase of any project. You can describe what you want to build in plain English (or whatever langauge you speak), ask "what if" questions, get suggestions for different approaches, and even have the AI help you break down complex ideas into manageable pieces.

The downside? Chat interfaces can feel limiting when you're working on anything beyond simple prototypes. Or if you need to work with some features that require native capabilities.

## Visual, Hosted Platforms for Quick Prototypes

If you're a designer or PM who thinks visually, platforms like **V0.dev**, **bolt.new** or **Figma Make** might be your handy choice. These tools specialize in turning descriptions (or even sketches) into good-looking pages, thanks to their own prompting and pre-defined components. Think of them as a step-up from the chat interfce with some specializations.

V0 and bolt.new simplifies the workflow by optimizing visual and deployment. You describe what you want, get the code, tweak it, and deploy. It can even take inspiration from design mockups you upload or imported from Figma. They can even help you build some apps with a backend that can be connected to databases, payments, etc so that you can turn your app into a monetizable product.

Figma Make is another tools from Figma that aims at helping designers quickly visualize their design. Designers can share their design with the tool, have it code, live preview on the side, make changes and then hand off code to developers for further development.

Depending on your goal, you may use them to get your initial "mood board" vibe with a few variations; you may also use them for for "V0" version before moving to other tools to refine into MVP prodcut; or if you're already satisfied with what they give you, just deploy it and call it a day.

## Editors and Plugins: Main Stream Choices

For both beginners and experiences developers, the most common way to use AI is through editors. **AI code editors & plugins** give you AI assistance right where most of coding already happens so you have a seamless transition experience.

**Cursor** is probably the star of this category. It's VSCode fork with many of their AI capabilities built in. If you're already using VSCode, the transition is seamless -- Cursor can import all your existing configurations and extensions with a few clicks. In addition to models from many providers in the market, they also trained their own models that solved some of the common issues with AI coding, like applying diffs and predictive edits (Many people prefer Cursor because of the Cursor Tab feature, where you just press Tab to accept the suggested edit).

**Windsurf** offers both a standalone editor and plugins for different IDEs. The standalone version has some interesting features like "Cascade" for building entire applications from scratch by breaking down your idea, architecting it, planning the development, and then coding it. They also have a "Supercomplete" that tries to predict what you want to do next (similar to Cursor tab).

Another great choice is **Augment Code**. It's a plugin for editors like VSCode and Jetbrains. It does magic for large codebases, thanks to their strategy and optimizations for codebase indexing. (They've got [a blog](https://www.augmentcode.com/blog/a-real-time-index-for-your-codebase-secure-personal-scalable) covering it.) It has a smart context engine that understands entire codebases and offers different modes for different types of work. You can start with a 14-day free trial with 300 messages. 

**GitHub Copilot** remains a solid choice, especially if you're already invested in the GitHub ecosystem. It provides code completions, autonomous coding workflows, natural language chat, and enhanced development actions.

## CLI Tools for the Experienced

**CLI tools** like **Claude Code** and **Aider** are for when you want to stay in your terminal and let AI work directly with your codebase. These tools understand entire projects, not just individual files, which makes them incredibly powerful for real development work.

Claude Code is like having an AI pair programmer who never gets tired. It can edit files across your entire codebase, fix bugs, answer questions about your architecture, and even handle git operations. The setup is dead simple -- just `npm install -g @anthropic-ai/claude-code` and you're ready to go.

Aider takes a similar approach but supports multiple AI models and has some nice extras like automatic commit messages and integration with linting tools. Both tools maintain security by connecting directly to AI APIs without sending your code through intermediate servers.

The beauty of CLI tools is that they work with your existing workflow. You don't need to learn a new interface -- just chat with AI right in your terminal.

## My Recommendations

Here's how I'd think about choosing your tools:

**Start with chat interfaces** for ideation and exploring your ideas. They're the most approachable and help you think through what you actually want to build. Use them to prototype quickly and get a feel for what's possible.

**Try UI generators** when you need to see visual progress fast. They're perfect for that "let me see how this might look" phase and for creating variations to explore different directions.

**Move to CLI tools or editors** when you're ready to implement and iterate seriously. These tools understand context better and can handle the complexity of real projects.

For most people, I'd recommend starting with **Cursor** as your main development environment. It hits the sweet spot of being approachable for beginners while still being powerful enough for experienced developers. Plus, the learning curve is gentle if you're already familiar with VSCode.

## Setting Up Cursor: Your New Coding Environment

Let's walk through getting Cursor set up since it's such a versatile choice. Think of this as setting up your new coding workspace.

When you first open Cursor, you'll notice it looks almost identical to VSCode -- that's intentional. The interface has three main areas where you'll interact with AI: the file editor (where you'll use Ctrl+K), the chat panel on the side (Ctrl+L), and the command palette for multi-file operations (Ctrl+I).

### Choosing Your AI Models

Here's where Cursor really shines compared to other tools -- you get to pick from multiple AI models, and each one has different strengths. Think of it like having different specialists on your team.

You'll want to set up 3-4 models for different purposes:

**A thinking model** for planning and architecture -- these are the heavy hitters like o3, Claude 4 Opus, or Claude 4 Sonnet with thinking mode enabled. Use these when you're figuring out how to approach a complex problem or when you need to think through the overall structure of what you're building.

**A long-context model** for understanding large codebases -- Gemini 2.0 Pro or Flash are great here. When you're working with many files and need the AI to understand how everything fits together, these models can handle much more information at once.

**Workhorse coding models** like Claude 3.5 Sonnet for the day-to-day coding work. These are fast, reliable, and great at following specific instructions once you have a plan.

Keep in mind that AI models evolve incredibly quickly -- by the time you're reading this, there might be newer, better options available. The key principle remains the same: use powerful thinking models for planning and fast, reliable models for executing those plans.

### MCP: Giving Your AI Superpowers

MCP (Model Context Protocol) is a way to give your AI access to additional tools and information. Think of it like installing apps on your phone -- each MCP tool adds new capabilities.

One tool I'd recommend starting with is **context7**, which helps the AI better understand your project structure and codebase. We'll dive deeper into MCP in later lessons, but for now, just know that it's a way to extend what your AI can do beyond just reading and writing code.

### Rules for AI: Teaching Your Assistant Your Style

Here's a game-changer that many people overlook: **Rules for AI**. In Cursor, this is a file called `.cursorrules` that lives in your project. Think of it as a instruction manual for how you want the AI to behave in your specific project.

You can specify coding styles, preferred libraries, best practices, workflows -- basically anything that would help a human developer understand how your team works. For example, you might include rules about using TypeScript, following certain naming conventions, or always including comments for complex logic.

If you're using other tools like Claude Code, you can create a similar file (often called `CLAUDE.md`) that gets included in every conversation.

The community has created tons of great examples -- check out the **awesome-cursorrules** repository on GitHub for inspiration. You'll find rules for different frameworks, languages, and project types that you can adapt for your own work.

## Your Next Steps

Don't feel like you need to master all these tools at once. Start with one that matches your current comfort level -- maybe a chat interface if you're new to coding, or Cursor if you're already comfortable with development environments.

The beauty of vibe coding is that you can start building things immediately, even if you don't understand every detail of how the tools work. As you get more comfortable, you can explore additional tools and features that help you work faster and build more complex projects.

In our next lesson, we'll dive into actually using these tools to build your first project and start developing that all-important "vibe" for working with AI effectively.